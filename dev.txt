＃エディターの仕様とか。
まず名前について。
最初に思いついたのは、これはハッシュを使うので「ハディター」だな。というのは、おｋジャストアンダスタンだと思ったのですが、コーヒー飲んだり、緑茶飲んだりしたら、「ちょっ！ハディターは間が抜けてるわ！」
と改めて思ったので、改題。
まあ、日記を作れるな。
というよりは、こういったフレームワークっぽいのは「TODO」作って、性能を試験するので、それっぽいので。
「ハッシュ使ってるから頭文字取ってH日記だわ！」
おｋ。アンダスタン。
https://i.pinimg.com/564x/c1/b6/41/c1b641af84c869c774a3f319c7fcbfb8.jpg
「いや、真面目なやつだよ。革新的だよ。ハッシュ使ってエディタとか」
ということで。
「hnikki！」です。このエディタの名前。
「えっちにっき」と呼ぶのかは、さておき。

＃真面目な仕様の話。
まずは、ラッパーを形成する。
ラッパーというのは、サーバーとやり取りするためのラッパー。
というのは、サーバー使わずとも、ひな形ができるわけですからね。
「まじで！」
これは、バックエンド側では「スタブ」なんて呼ばれているやつかもしれない。
そんな大したものではないのですが。
さて。
「使うのはlocalStorageさんだ！」
いつも思う。
「ECMAのネーミングセンス死んでる。。。」
誰だよ、タイピングミスしてくれよ。みたいな、長い名前考えつくのは。
しかし、まあ、インターフェイスは至って単純。
---
var ls = localStorage
ls.getItem(key)
ls.setItem(key,data)
---
「リスト検索は？　ねえ、エンティティさん！」
エンティティ使えねえ。
チェイニングしたいのに、チェイニング。
キー、バリューにすれば終わる話なのに。
というのでラッパーは必要ですね。
---
var stock={}
await stock.load(file)
await stock.save(file,data)
await stock.isfile(file)
await stock.getindex(searchword); //null is all file list
---
サーバーは意識させませんよ。ローカルストレージだから。
さらには、このスタブは、インターフェイスだけ同じにして、内容を替えれば、サーバー側に適用できるように。
ローカルストレージの場合、単純にロードとセーブが、ゲットアイテム、セットアイテムにマッピングされる感じで、あとは、エンティティを「key,valueにして！」取得できるようにする必要が多分あるよ。エンティティ。
「ファイルリスト作れば勝ちだよね？」
https://i.pinimg.com/564x/4e/2d/fe/4e2dfeec9b5c955b0fc11e2580fb10a3.jpg
「そのとおり」
今の時代、それがサーバーなのかローカルなのか、どちらでも構わない。
よし。改題。

＃違和感あるけど「.../index.html#majide.txt」は可能
大事なのは表題の後ろの方だよ。
「アンカーにドット使える！」
これは、W3C的には正式な仕様のようです。
「末尾の拡張子でファイルとか判定しよう」
なんて、いう、なんちゃってチェックをURLにしてはいけませんね。
---
new URL()
---
しよう。
そしてクエリーとハッシュを分離するんだ。
「システムから！」
https://i.pinimg.com/564x/12/58/de/1258de7c84e1650f4929d892a069ed2b.jpg
いや。システムちゃう。URLな。
まあ、真面目な話、ブラウザのURL欄に直接アンカーを入れておけば、ファイルが作れるようなことが可能なわけで。
これ何がすごいんだって話かもしれないけど、クライアント側で、ほぼ全ての処理を行なって、「サーバーにはデータ送るだけ！」
何もしない。「はい、JSONです」みたいなやつ。
クライアントのCPUGPU使い放題。というのが魅力ですね。
んで。直書きの話に戻って。
たとえば、
---
https://.../#hogehoge.txt
---
はい。hogehoge.txt生成。あとは何か書いて。
このhnikkiはそれが可能です。
URLの内部ハッシュの変更は「hashchangeイベントで取れるから！」
URL直書きして「メモるか」みたいな。名前もブラウザに直接書き込んだものでできます。
リネームさせるかはさておき。
次にするのは、画像どうするの？みたいな話ですね。
＠dev2へ#dev2
