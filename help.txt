＃hashsanを使ってミニマムな開発。
はっしゅさんは、MVCにおけるコントローラーの役割をするものです。
ハッシュの検出。ここでいうハッシュとは、アンカーと呼ばれる＃で始まるものです。
aタグについてくるやつな。---<a href="#">shaaaap</a>---
たとえば「#home」など、内部リンクに移動すると、はっしゅさんは反応します。
はっしゅさんのインターフェイスは単純です。
---
hahsan.add(filter,renderfunction)
hashsan.start(firstAnchor)
---
基本使うのは二つのみ。
あどどして最後にスタートします。
まず、デバッグ用から、
hashsan.debug = true
にして、
hashsan.ishash('#home')
チェックしたいハッシュを入れます。
あどどしたハッシュが実際に検出できるかをチェックできます。
無かったら「ishash」は当然「false」ですので、これでまず最初のチェック。
---
hashsan.start('#home')
---
でもいいけどな。
追記：ここでいう検出は「.add(filter,...)したものに引っかかるか！」どうかなので、内部のリンクに指定のアンカーリンクいれたところで、関数実行しません。
こういうのはケーススタディ。
動くやつ：
---
hashsan.add('#home',()=>{ console.log('this is the #home') })
hashsan.start('#home') //yes, do it.
hashsan.ishash('#home') //true
---
一方で動かないやつ：
---
htmlとかに<a href="#home">hogehoge</a>
hashsan.start('#home') //no working
hashsan.ishash('#home') //false
//need hashsan.add add add...
---
ぐらいで。あどどして、フィルダー関数をいれて。文字列でもいいけど。
はっしゅさんのイズハッシュに引っかからないものは、何も起きません。
これは副作用がない半面、何も起きないので、必ずチェックしたほうがいい。
逆にフィルター関数で、内部リンクの変更を全て引っ張る方法も考えられますが、はっしゅさんは、レンダー関数をひとつのみ呼び出すので、フィルターに二つ引っかかると最初に登録したものしか、引っ張れません。
改良するべきかと云うと。うーん。
これは、バブリングの問題でバブリングは現在しない仕様。
「仕様なの？」
https://i.pinimg.com/564x/1e/bd/af/1ebdafc7c138d081d1f6c5e911d60228.jpg
「うん。（おま、たべるかどっちかにしろよ）」
ということで。
全部、内部リンクの変更を検出することは、できないと思ったほうがいいです。
「そんなに、ざっくり、デバッグモードかよ！」な時は、ありますが。
このCSSテーマはfujiyama。
